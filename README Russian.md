# Основные правила и принципы написания CSS

Большие, долгоживущие проекты с участием множества разработчиков требуют от
нас выполнять работу определённым образом для достижения следующих (помимо всех прочих) целей:

* Создавать легко поддерживаемые файлы стилей
* Писать понятный и читаемый код
* Делать стили масштабируемыми

Несколько техник помогут нам достичь этих целей.

Первая часть этого документа расскажет про синтаксис, форматирование и анатомию CSS,
вторая часть будет посвящена созданию правильного способа мышления и особого отношения к написанию
и структурированию CSS-кода. Звучит многообещающе?

## Содержание

* [Анатомия CSS-документа](#Анатомия-css-документа)
  * [Общие моменты](#Общие-моменты)
  * [Один файл или много файлов](#Один-файл-или-много-файлов)
  * [Оглавление](#Оглавление)
  * [Названия секций](#Названия-секций)
* [Организация правил](#Организация-правил)
* [Анатомия CSS-правила](#Анатомия-css-правила)
* [Правила именования](#Правила-именования)
  * [JS-классы](#js-классы)
  * [Интернационализация](#Интернационализация)
* [Комментарии](#Комментарии)
  * [Комментарии на стероидах](#Комментарии-на-стероидах)
    * [Квази-селекторы](#Квази-селекторы)
    * [Теги в коде](#Теги-в-коде)
    * [Ссылки между объектом и его расширением](#Ссылки-между-объектом-и-его-расширением)
* [Напиcание CSS](#Напиcание-css)
* [Создание новых компонентов](#Создание-новых-компонентов)
* [OOCSS](#oocss)
* [Разметка](#Разметка)
* [Единицы измерения](#Единицы-измерения)
  * [Размер текста](#Размер-текста)
* [Сокращённая запись](#Сокращённая-запись)
* [Идентификаторы](#Идентификаторы)
* [Селекторы](#Селекторы)
  * [Перенасыщенные селекторы](#Перенасыщенные-селекторы)
  * [Производительность селекторов](#Производительность-селекторов)
* [Последовательность CSS-селекторов](#Последовательность-css-селекторов)
* [`!important`](#important)
* [Магические числа и абсолютные значения](#Магические-числа-и-абсолютные-значения)
* [Стили в условных комментариях](#Стили-в-условных-комментариях)
* [Отладка](#Отладка)
* [Препроцессоры](#Препроцессоры)

---

## Анатомия CSS-документа

Мы всегда должны стараться соблюдать принятое форматирование. Это означает согласованные правила комментирования, согласованный синтаксис и согласованное, логичное именование.

### Общие моменты

Ограничьте строки 80 символами, где это только возможно. Исключениями могут быть синтаксис градиентов и ссылки в комментариях. Это нормально, тут мы ничего не можем поделать.

Вместо табов я предпочитаю использовать отступы в четыре пробела, а также рекомендую писать многострочный CSS.

### Один файл или много файлов

Если вы предпочитете работать с одиночными, большими файлами, при следовании данному руководству у вас не прибавится проблем. Когда я начал использовать Sass, то стал разбивать стили на множество маленьких, подключаемых через `include`. Такой вариат тоже подойдет. Как бы там ни было, правила и рекомендации, приведённые ниже, применимы к обоим способам. Единственное замечание относится к «Оглавлению» и «Названиям секций». Продолжайте читать, чтобы узнать подробности.

### Оглавление

В начале CSS файла я храню таблицу содержимого, которая уточняет какие секции содержатся в этом файле, например:

    /*------------------------------------*\
        $CONTENTS
    \*------------------------------------*/
    /**
     * CONTENTS............You’re reading it!
     * RESET...............Set our reset defaults
     * FONT-FACE...........Import brand font files
     */

Оглавление подскажет следующему разработчику, что ему можно ожидать в этом файле. Каждый пункт оглавления совпадает с названием секции.

Если вы работаете с одним большим файлом стилей, то секция, попавшая в оглавление, также должна находиться в этом файле. Если вы работаете со стилями, разнесёнными в несколько файлов, то каждый пункт оглавления привязан к команде подключения файла с этой секцией.

### Названия секций

Оглавление будет бесполезно пока не будет соотноситься с названиями секций. Оформляйте секцию таким способом:

    /*------------------------------------*\
        $RESET
    \*------------------------------------*/

Префикс `$` в названии секции позволяет вбить в поиске ([CMD|CTRL]+F) `$[НАЗВАНИЕ-СЕКЦИИ]` и, таким образом, **ограничить выдачу поискового запроса только названиями секций**.

Работая с большим файлом стилей, оставляейте отступ в пять строк между секциями, вот так:

    /*------------------------------------*\
        $RESET
    \*------------------------------------*/
    [Our
    reset
    styles]
     
     
     
     
     
    /*------------------------------------*\
        $FONT-FACE
    \*------------------------------------*/

Этот участок пустого пространства легко и быстро бросается в глаза при пролистывании большого файла.

При работе с несколькими подключаемыми файлами стилей начинайте каждый файл с названия секции.  В этом случае оставлять пустые строки необязательно.

## Организация правил

Возьмите за правило писать стили в определенном порядке. Благодаря этому вы получите все преимущества наследования и, собственно, каскадности (Cascading) стилей.

Порядок правильно организованного файла стилей примерно таков:

1. **Reset** – первый уровень, платформа для написания кода стилей.
2. **Элементы** – `h1`, `ul` и подобные без указания классов.
3. **Объекты и абстракции** — базовая, обобщенная структура CSS-дизайна.
4. **Компоненты** – готовые компоненты, построенные из объектов и их расширений.
5. **Полезные стили** – состояния ошибок и прочее.

Это означает, что по мере чтения этого документа нужно иметь в виду, что каждая секция, написанная ниже, строится и наследует правила, описанные в предыдущих. Следуя этой структуре, вы сможете избежать проблем специфичности и отменяющих переопределений, и в целом прийти к более качественной CSS архитектуре.

За более подробной информацией по теме модульной архитектуры CSS обращайтесь к книге Джонатана Снука ["Scalable and Modular Architecture for CSS (SMACSS)"](http://smacss.com). 

## Анатомия CSS-правил

    [Селектор] {
        [Свойство]:[Значение]
        [<-   Объявление  ->]
    }    

Я руководствуюсь несколькими правилами при написании CSS-правил.

* Используйте дефис как разделитель (исключением является БЭМ запись,
  [смотрите ниже](#Правила-именования))
* Делайте отступ в 4 пробела
* Используйте многострочность
* Сортируйте свойства в порядке релевантности (НЕ в алфавитном)
* Выравнивайте свойства с вендорными префиксами так, чтобы их значения были друг под другом.
* Используйте отступы в стилях, чтобы отразить структуру HTML.
* Всегда заканчивайте объявление знаком точки с запятой

И сразу пример:

    .widget{
        padding:10px;
        border:1px solid #BADA55;
        background-color:#C0FFEE;
        -webkit-border-radius:4px;
           -moz-border-radius:4px;
                border-radius:4px;
    }
        .widget-heading{
            font-size:1.5rem;
            line-height:1;
            font-weight:bold;
            color:#BADA55;
            margin-right:-10px;
            margin-left: -10px;
            padding:0.25em;
        }

Наглядно видно, что `.widget-heading` является дочерним элементом `.widget`, так как `.widget-heading` имеет дополнительный отступ относительно селектора `.widget`. Эту полезную информацию разработчики могут считать просто взглянув на отступы в наших стилях.

Также мы видим, что объявления селектора `.widget-heading` отсортированы в порядке релевантности; `.widget-heading` вероятнее всего текстовый элемент, поэтому мы начинаем правило с типографских свойств, за которыми уже следуют все остальные.

Единственное исключение в многострочном CSS может быть в таком случае:

    .t10    { width:10% }
    .t20    { width:20% }
    .t25    { width:25% }       /* 1/4 */
    .t30    { width:30% }
    .t33    { width:33.333% }   /* 1/3 */
    .t40    { width:40% }
    .t50    { width:50% }       /* 1/2 */
    .t60    { width:60% }
    .t66    { width:66.666% }   /* 2/3 */
    .t70    { width:70% }
    .t75    { width:75% }       /* 3/4*/
    .t80    { width:80% }
    .t90    { width:90% }

В этом примере (из [сеточной системы inuit.css](https://github.com/csswizardry/inuit.css/blob/master/inuit.css/partials/base/_tables.scss#L88))
гораздо больше смысла писать CSS в одну строку.

## Правила именования

В большинстве случаев я использую дефис как разделитель слов в классах (например `.foo-bar`, не `.foo_bar` и не `.fooBar`), но в некоторых случаях я использую БЭМ-запись.

<abbr title="Блок, Элемент, Модификатор">БЭМ</abbr> — методология именования и категоризации CSS селекторов для приведения их в чёткий порядок, придания прозрачности и информативности.

БЭМ-именование происходит по следующему шаблону:

    .block{}
    .block__element{}
    .block--modifier{}

* `.block` представляет собой наивысший уровень абстракции или компонента.
* `.block__element` является вложенным элементом `.block`, формирующим `.block` как сущность.
* `.block--modifier` — класс отражающий другое состояние или версию `.block`.

**Аналогия**, иллюстрирующая работу БЭМ, может быть такой:

    .person{}
    .person--woman{}
        .person__hand{}
        .person__hand--left{}
        .person__hand--right{}

В этом примере приведен базовый объект описывающий человека, и существует отличный от базового тип человека — женщина. Также наглядно видно, что у людей есть руки; они являются частями человека, и рука может быть как левой, так и правой.

Теперь мы можем создавать селекторы, опираясь на базовые объекты и также без проблем понимаем, что делает каждый конкретный селектор; является ли он частью компонента (`__`) или же модификацией (`--`)?

Итак, `.page-wrapper` является отдельным селектором; он не формирует часть компонента и, значит, является валидным селектором. В противовес этому, селектор `.widget-heading` относится к компоненту; он является дочерним элементом `.widget` и поэтому мы вынуждены переименовать этот класс в `.widget__heading`.

БЭМ непригляднее и перегруженней, но, тем не менее, он предоставляет огромные возможности, с помощью которых мы можем определить назначение и отношения элементов просто посмотрев на их классы. Также, БЭМ обычно сжимается c помощью gzip, после использования минификаторов, которые первоклассно работают с повторениями.

Независимо от того, используете вы БЭМ или нет, всегда заботьтесь о грамотном именовании классов; классы должны быть короткими, насколько это возможно, но настолько длинными, насколько это необходимо. Убедитесь, что объекты и абстракции проименованы достаточно расплывчато (например `.ui-list`, `.media`) для возможного переиспользования. Расширения объектов, напротив, должны иметь гораздо более конкретные имена (например `.user-avatar-link`). Не беспокойтесь, если наименования будут очень длинными; хорошо написанный код gzip сжимает *превосходно*.

### Классы в HTML

Для большей читаемости разделяйте классы в разметке двумя (2) пробелами:

    <div class="foo--bar  bar__baz">

Увеличенные отступы между классами позволят легко вычленять отдельные классы.

### JS-классы

**Никогда не используйте в JavaScript-логике обычные, уже используемые для _стилизации_ классы.** Связывание логики скриптов с оформлением ведёт к тому, что мы не сможем использовать одно без другого.

Если вам требуется привязать к вёрстке какую-то логику, используйте специальный JS-класс — обычный класс, дополненный префиксом `.js-`, например `.js-toggle`, `.js-drag-and-drop`. Данный приём позволяет добавлять JS- и CSS-классы, без создания самому себе проблем в будущем, а также разделяет логику поведения и оформление страницы друг от друга.

    <th class="is-sortable  js-is-sortable">
    </th>

Приведенная в пример разметка имеет два класса; один предназначен для оформления сортируемых табличных колонок и другой для того, чтобы вы могли добавить возможность сортировки.

###Интернационализация

Несмотря на то, что я британский разработчик и привык писать <i>colour</i> вместо <i>color</i>, считаю, что для улучшения однородности лучше использовать американский английский при написании CSS. CSS, как и другие (если не все) языки,
написан на американском английском, так что сочетание `color:red;` с классами `.colour-picker{}` вредит однородности кода. Я ранее предлагал и отстаивал написание селекторов на двух языках, например:

    .color-picker,
    .colour-picker{
    }

Тем не менее, работая недавно над очень большим Sass-проектом, в котором было множество colour-переменных (например, `$brand-color`, `$highlight-color` и т.д.), я осознал, что поддержка двух версий каждой переменной очень скоро становится утомительна. Это также означает в два раза больше работы с такими вещами, как поиск и замена.

Для однородности всегда называйте классы и переменные на той локализации языка, которая в нём принята.

## Комментарии

Я использую комментарии в стиле docBlock, которые я ограничиваю в 80 символов:

     /**
     * Пример комментария в стиле docBlock
     *
     * Вот длинный комментарий, описывающий код более
     * подробно. Такие комментарии также ограничиваются длиной в 80 символов
     * для каждой строки.
     *
     * Вы можете добавлять разметку в комментарии, 
     * и я даже _рекомендую_ делать это:
     * 
       <div class=foo>
           <p>Lorem</p>
       </div>
     * 
     * Код в комментариях не дополняется звездочками в начале строки,  
     * так его проще скопировать.
     * 
     * 
     */

Вам следует документировать и комментировать всё, что только возможно. То, что кажется вам очевидным и говорящим за себя, может не быть таковым для другого разработчика. Пишите кусок кода и сразу после этого объясняйте его.

### Комментарии на стероидах

Существуют несколько продвинутых техник, связанных с комментариями:

* Квази-селекторы
* Теги в коде
* Ссылка на расширяемый компонент

#### Квази-селекторы

Никогда не перегружайте селектор; например, не стоит писать `ul.nav{}`, если можно написать просто `.nav{}`. Перегрузка селекторов приводит к уменьшению их производительности (увеличению времени рендеринга страницы), исключает возможность потенциального переиспользования селектора для элемента другого типа и увеличивает специфичность селектора. Этого нужно  избегать любой ценой.

Тем не менее, иногда бывает полезно сообщить следующему разработчику, в каком контексте вы собираетесь использовать селектор. Давайте рассмотрим `.product-page`. Этот класс выглядит так, как будто должен использоваться с корневыми элементами, такими как `html` или `body`. Но глядя только на `.product-page` нет возможности утверждать наверняка, с каким именно элементом он связан.

Используя смешанные селекторы (например, комментирование первого простого селектора по типу), мы можем сообщить с каким элементом следует использовать этот класс:

    /*html*/.product-page{}

В этом примере мы чётко видим к какому элементу принадлежит данный класс, без проблем со специфичностью или невозможностью переиспользования этого кода.

Другие примеры могут быть такими:

    /*ol*/.breadcrumb{}
    /*p*/.intro{}
    /*ul*/.image-thumbs{}

Теперь мы можем увидеть к чему применён каждый класс, не увеличивая специфичность селектора.

#### Теги в коде

Когда вы пишете новый компонент, указывайте над ним несколько тегов исходя из его назначения, например:

    /**
     * ^navigation ^lists
     */
    .nav{}
    
    /**
     * ^grids ^lists ^tables
     */
    .matrix{}

Теги позволяют разработчикам находить сниппеты поиском по названию тега. Если 
разработчику понадобится поработать со списками, он может начать искать `^lists` и найдёт объекты `.nav` и `.matrix` (и, возможно, больше).

#### Ссылки между объектом и его расширением

Используя методы OOCSS, вы часто будете иметь два участка кода. Один — "скелет" приложения (объект) и второй — его "кожа" (расширение). Да, они тесно связаны, но при этом, естественно, находятся в разных местах. Для установления чёткой связи между объектом и его расширением мы применяем *указатели между объектом и его расширением*. Это обычные комментарии вот такого вида:

В вашем основном файле стилей они будут выглядеть так:

    /**
     * Extend `.foo` in theme.css
     * (Дополнен классом `.foo` в theme.css)
     */
     .foo {}

В файле стилей темы — так:

    /**
     * Extends `.foo` in base.css
     * (Дополняет класс `.foo` из base.css)
     */
     .bar{}

Тем самым мы получили устойчивую связь между двумя связаными логически, но физически разделёнными элементами кода.

---

## Напиcание CSS

Предыдущая часть была посвящена тому, как мы структурируем и форматируем наш CSS, и там существовали более-менее чёткие правила.

Следущая часть будет немного более теоретической и повествует о наших способах мышления и подходах.

## Создание новых компонентов

При создании нового компонента пишите разметку **до того**, как напишите хоть одну строчку CSS. Это позволяет увидеть, какие свойства наследовались и избежать повторного применения избыточных стилей.

Если вы будете писать сначала разметку, то сможете сфокусироваться на информации, контенте и семантике и только *после всего этого* применять соответствующие классы и стили.

## OOCSS

Я использую OOCSS подход и разделяю компоненты на структуру (объекты) и оформление (расширения). Как **аналогию** (не пример) можно рассмотреть следующее:

    .room{}
    
    .room--kitchen{}
    .room--bedroom{}
    .room--bathroom{}

Мы располагаем комнатами нескольких типов, но все комнаты имеют похожие свойства; в каждой комнате есть пол, потолок, стены и двери. Мы можем обобщить эту информацию в общем классе `.room{}`. Тем не менее, у нас есть специальные отличающиеся друг от друга типы комнат; кухня должна иметь плитку на полу, спальня — ковёр; в ванной не должно быть окна, а в спальне, напротив, должно. В каждой комнате скорее всего стены покрашены в свой цвет. OOCSS учит нас абстрагировать похожие свойства в базовый объект и в дальнейшем дополнять его с помощью расширяющих классов для добавления особенных качеств.

Вместо того, чтобы плодить множество уникальных компонентов, постарайтесь обнаружить среди всех шаблонов в дизайне повторяющиеся элементы и создайте соответствующие им классы для многократного использования. Поэтому сначала создайте этот скелет в виде базовых объектов, а затем используйте уточняющие классы, расширяя их стили в определённых уникальных ситуациях.

Если вы вынуждены создать новый компонент, то разделите его на структуру и декоративное оформление; постройте структуру используя общие классы, тем самым давая возможность использования структуры компонента в других местах вашего проекта, и затем, используя более специфичные классы, оформите компонент в соответствии с требованиями дизайна.

## Разметка

Все компоненты должны быть полностью независимы от ширины; они должны оставаться "резиновыми" и их ширина должна контролироваться системой модульных сеток.

Высота **никогда** не должна назначаться элементам. Высота применяется только на сущности, имевшие размеры _до того_, как попали на сайт (например, картинки и спрайты). Никогда не устанавливайте высоту на `p`, `ul`, `div`, да и вообще ни на что не устанавливайте. Часто вы можете добиться желаемого эффекта при помощи гораздо более гибкого `line-height`.

Систему модульных сеток следует понимать как книжные полки. На них находится важное содержимое, но они не содержат его в себе. Вы создаёте свои полки, а затем наполняете их своими вещами. Отделяя систему модульных сеток от созданных нами компонентов, вам будет намного проще менять расположение компонентов на сайте, чем если бы размеры были бы заданы напрямую; это делает нашу разработку клиентской части более гибкой и быстрой в работе.

Никогда не применяйте никаких стилей к элементам сетки, так как они нужны лишь для разметки. Применяйте стили только к *содержимому ячейки*. Никогда, *ни в коем случае* не применяйте свойство `box-model` к ячейкам сетки.

## Единицы измерения

Я обычно использую сочетание методов задания размеров интерфейса: проценты, пиксели, `ems`, `rems` или вообще не задаю единицы измерения.

Ячейки сетки в идеале должны иметь размеры в процентах. Используя сетку для управления колонками на страницах, я оставляю компоненты полностью свободными от размеров (как я рассказывал ранее).

Размеры шрифтов я устанавливаю в `rem` c запасным решением с использованием пикселей. Этот метод предоставляет доступность контента как с `em` и уверенность при использовании пикселей. Вот простой Sass-миксин для одновременной работы с пикселями и `rem` (разумеется, вы должны сначала заранее определить переменную `$base-font-size` в стилях):

    @mixin font-size($font-size){
        font-size:$font-size +px;
        font-size:$font-size / $base-font-size +rem;
    }

Я использую пиксели только для элементов, размеры которых предопределены до попадания на сайт — в основном, это картинки и спрайты, чьи размеры изначально заданы в пикселях.

### Размер текста

Я составил список классов (похожих на модульную сетку) для задания размера текста. Эти классы могут быть использованы для стилизации текста в двухцепочечной иерархии. Моя статья «[Pragmatic, practical font-sizing in CSS](http://csswizardry.com/2012/02/pragmatic-practical-font-sizing-in-css)» расскажет вам, как это работает.

## Сокращённая запись

**Сокращённую CSS запись следует использовать с осторожностью.**

Может показаться заманчивым использовать такие правила, как `background: red;`, но делая это, мы на самом деле говорим: «Я хочу, чтобы фоном не было скролящейся картинки, находящейся сверху-слева и повторяющейся по горизонтали и вертикали, и чтобы цвет фона был красный». В девяти случаях из десяти это не вызовет никаких проблем, но в 10% обязательно доставит достаточно неприятностей, чтобы не использовать сокращенные записи. Вместо этого используйте `background-color: red;`.

То же самое касается правила `margin: 0;` —да, оно ясное и короткое, но, повторю, нужно писать **ясный, подробный** код. Если вы на самом деле хотели воздействовать только на нижний отступ элемента, то лучше использовать `margin-bottom: 0;`.

Старайтесь сохранять чёткое представление о свойствах, которые вы устанавливаете и следите за тем, чтобы случайно не сбросить свойства других элементов, используя сокращенную запись. Например, если вы хотите сбросить нижний отступ, то нет никакой необходимости в сбрасывании всех отступов с помощью `margin: 0;`.

Сокращения — это благо, но при неправильном использовании они могут принести много вреда.

## Идентификаторы

Небольшое замечание об идентификаторах в CSS, прежде чем мы углубимся в селекторы в целом.

**НИКОГДА не используйте идентификаторы в CSS.**

Они могут встречаться в вашей разметке для JS и идентификации фрагментов, но для стилизации используйте только классы. У вас не должно быть ни одного идентификатора в любом из ваших файлов стилей!

Преимущество классов в их многоразовости (мы можем использовать их заново) и они обладают низкой специфичностью. Высокая определенность — это один из скорейших путей к возникновению проблем в проектах, поэтому необходимо любыми способами  стремиться к снижению специфичности. Идентификаторы в **255** раз более определенны, чем классы, так что больше не используйте их в CSS _никогда_.

## Селекторы

Сохраняйте селекторы короткими, эффективными и переносимыми.

Тяжелые, глубоко вложенные селекторы никуда не годятся по ряду причин. Например возьмем `.sidebar h3 span {}`. Этот селектор сильно привязан к существующей разметке и поэтому нет возможности переместить `span` из `h3` и из `.sidebar`, следовательно, нет возможности обеспечить поддержку стилей на должном уровне.

Слишком длинные селекторы также вызывают проблемы производительности; чем больше проверок в селекторе (например, селектор `.sidebar h3 span` имеет три проверки, а `.content ul p a` — четыре), тем больше работы выполняет браузер.

Убедитесь, что ваши стили не зависят от вложенности, насколько это возможно, а также что ваши селекторы короткие и легко воспринимаемые.

Селекторы в основном должны быть короткими (например, состоящими из одного класса), но имена классов должны быть настолько длинными, насколько это требуется. Класс `.user-avatar` намного лучше, чем `.usr-avt`.

**Запомните:** Классы на самом деле ни семантичны, ни несемантичны; они могут использоваться рационально или нерационально! Перестаньте беспокоиться о «семантике» имён классов и выберите для своего класса какое-нибудь удобное и перспективное имя.

### Перенасыщенные селекторы

Как говорилось выше, увидеть специфичный селектор — всегда плохой знак.

Возьмем такой перенасыщенный (гиперспецифичный) селектор, как `div.promo`. Скорее всего, мы можем достичь тот же самый эффект, используя лишь `.promo`. Конечно, иногда мы _хотим_ указать зависимость класса от элемента (например, если у вас есть общий класс `.error`, который должен выглядеть по разному при разных элементах (например, `.error { color: red; }` `div.error { padding: 14px; }`)), но по возможности избегайте этого, где это только возможно.

Другим примером слишком перенасыщенного селектора может быть `ul.nav li a {}`. Как описано выше мы сразу можем выкинуть `ul`, и так как мы знаем, что `.nav` это список, то ссылка будет вложена только в `li`, поэтому мы можем сократить `ul.nav li a {}` до `.nav a`.

### Производительность селекторов

Хоть это и правда, что браузеры только улучшают свои показатели в скорости рендеринга CSS, эффективность — это то, на чём мы можем быть сфокусированы всегда. Короткие, не вложенные селекторы, избежание универсального (`* {}`) селектора, как основного, и избежание больших комбинаций CSS3-селекторов должны помочь обойти проблемы производительности.

## Последовательность CSS-селекторов

Вместо использования селекторов, спускающихся по всему DOM-дереву, чаще удобнее добавить требуемому элементу класс. Давайте рассмотрим конкретную ситуацию на примере `.header ul{}`…

Давайте представим, что `ul` — главная навигация на вашем сайте. Этот элемент находится в шапке сайта, как вы и ожидаете, и при этом не повторяется; `.header ul{}` будет работать, но он не идеален и мы не рекомендуем его использовать. Этот селектор небезопасен в будущем и, как минимум, недостаточно точен. Проблема станет очевидна так скоро, как вы добавите ещё один `ul` в шапку сайта — новый элемент унаследует все стили нашего главного меню, и шансы, что мы так и задумали, весьма невелики. Это приведёт к вынужденному рефакторингу большого количества кода _или_ отмене большинства стилей для второго `ul`, чтобы уничтожить последствия недостаточно специфичного селектора.

Составляющие селектора должны отвечать причинам стилизации чего-либо; спросите себя **«Я пишу этот селектор именно, потому что `ul` вложен в `.header` или из-за того, что этот элемент — это главное меню на моём сайте?»**. Ответ опреляет правильный селектор.

Убедитесь, что ключевые элементы селектора не являются простыми селектороми элемента/типа или классами объекта/абстракции. Вы никогда не должны писать селекторы похожие на `.sidebar ul{}` или `.footer .media{}` в вашем файле стилей темы.

Будьте точны, конкретны; указывайте именно тот элемент, на который вы хотите воздействовать, не его родитель. Никогда не предполагайте, что разметка будет неизменной. **Пишите селекторы, нацеленные на нужные элементы, а не на те, которые есть в данный момент.**

Для полного объяснения прочитайте мою статью [Shoot to kill; CSS selector intent](http://csswizardry.com/2012/07/shoot-to-kill-css-selector-intent/)

## `!important`

Допустимо использовать `!important` только на вспомогательных классах. Превентивно добавлять `!important` удобно и полезно, например, если вы знаете, что селектор `.error { color: red !important; }` **всегда** должен нуждаться в наибольшем приоритете.

Не приветствуется использование `!important` для исправления ошибок, например, чтобы помочь выбраться себе из ситуации с запутанной специфичностью. Переработайте ваш CSS и старайтесь избегать этих проблем рефакторингом ваших селекторов. Сохраняйте ваши селекторы короткими, откажитесь от ID — и ваша жизнь станет проще.

## Магические числа и абсолютные значения

Магическое число — число используемое лишь потому, что «это просто работает». Это порочная практика, так как очень редко она работает по какой-либо реальной причине и обычно достаточно недальновидна, негибка и причина появления самого числа вероятнее всего забудется. Магические числа устраняют симптомы, но не никак не влияют на проблему.

Например, использование `.dropdown-nav li:hover ul { top: 37px; }`, чтобы расположить выпадающее меню внизу навигации не принесёт ничего хорошего, так как `37px` магическое число. Оно работает только потому, что в этом конретном сценарии элемент `.dropdown-nav` оказался высотой в 37 пикселей.

Вместо этого мы должны использовать `.dropdown-nav li:hover ul { top: 100%; }`, что означает: вне зависимости какой высоты будет меню `dropdown-nav`, выпадающее всегда будет сдвинуто на 100% от верхней границы родителя.

Каждый раз, когда вы жёстко задаёте число, подумайте дважды; если вы можете избежать этого — избегайте, например, используя ключевые слова или синонимы (`top: 100%;` для того, чтобы сдвинуть на 100% от верха) или — даже лучше — не используя никаких единиц измерений.

Каждое установленное вами числовое значение, скорее всего, является необязательным.

## Стили в условных комментариях

Использования отдельных файлов стилей для IE, по большому счёту, можно избежать. Исключением может быть необходимость восполнить вопиющие недостатки поддержки различных свойств (например, PNG с альфа–каналом в IE6).

Главное правило: вся разметка и `box-model` правила могут и _будут_ работать без дополнительных файлов стилей, если вы отрефакторите и переработаете ваш CSS. Это означает, у вас никогда не должно быть `<!--[if IE 7]> element{ margin-left:-9px; } < ![endif]-->` и тому подобных вещей, используемых лишь для того, чтобы «заставить что-то работать правильно».

## Отладка

Если вы столкнулись с проблемой в CSS, то **удаляйте куски кода до того, как начать добавлять новые правила** в попытке решить проблему. Проблема кроется в уже написанном CSS, написать ещё больше стилей — не самое верное решение!

Удаляйте куски разметки и стилей, пока проблема не исчезнет, затем определите, в какую часть кода закралась проблема.

Порой очень заманчиво добавить `overflow: hidden;` нужному элементу, чтобы избавиться от результатов кривой вёрстки, но `overflow` сам по себе вряд ли был проблемой; **исправляйте проблему, а не её симптомы.**

## Препроцессоры

Sass — мой выбор среди препроцессоров. **Используйте его с умом** 
Используйте Sass, чтобы сделать ваш CSS более мощным, но избегайте вложенности, как чумы! Используйте вложенность только тогда, когда это действительно необходимо в чистом CSS, например:

    .header{}
    .header .site-nav{}
    .header .site-nav li{}
    .header .site-nav li a{}

Такой код был бы полностью избыточным в нормальном CSS, и поэтому следущий Sass-код **никуда не годится**:

    .header{
        .site-nav{
            li{
                a{}
            }
        }
    }

Если вы хотите написать этот кусок, испольуя Sass, следует делать это так:

    .header{}
    .site-nav{
        li{}
        a{}
    }




![](https://secure.gaug.es/track.gif?h[site_id]=52036088108d7b260f0002f9&h[resource]=https%3A%2F%2Fgithub.com%2Fmatmuchrapna%2FHampi%2Fblob%2Fmaster%2FREADME.md)
